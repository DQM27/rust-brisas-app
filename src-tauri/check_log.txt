    Checking mega-brisas v1.0.0-alpha (C:\Users\femprobrisas\proyecto-brisas\Rust\brisas-app\src-tauri)
error[E0428]: the name `CreateGafeteInput` is defined multiple times
   --> src\models\gafete.rs:169:1
    |
 29 | pub struct CreateGafeteInput {
    | ---------------------------- previous definition of the type `CreateGafeteInput` here
...
169 | pub struct CreateGafeteInput {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `CreateGafeteInput` redefined here
    |
    = note: `CreateGafeteInput` must be defined only once in the type namespace of this module

error[E0428]: the name `CreateGafeteRangeInput` is defined multiple times
   --> src\models\gafete.rs:176:1
    |
 36 | pub struct CreateGafeteRangeInput {
    | --------------------------------- previous definition of the type `CreateGafeteRangeInput` here
...
176 | pub struct CreateGafeteRangeInput {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `CreateGafeteRangeInput` redefined here
    |
    = note: `CreateGafeteRangeInput` must be defined only once in the type namespace of this module

error[E0428]: the name `GafeteCreateDTO` is defined multiple times
   --> src\models\gafete.rs:199:1
    |
 45 | pub struct GafeteCreateDTO {
    | -------------------------- previous definition of the type `GafeteCreateDTO` here
...
199 | pub struct GafeteCreateDTO {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ `GafeteCreateDTO` redefined here
    |
    = note: `GafeteCreateDTO` must be defined only once in the type namespace of this module

error[E0428]: the name `GafeteResponse` is defined multiple times
   --> src\models\gafete.rs:211:1
    |
 55 | pub struct GafeteResponse {
    | ------------------------- previous definition of the type `GafeteResponse` here
...
211 | pub struct GafeteResponse {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^ `GafeteResponse` redefined here
    |
    = note: `GafeteResponse` must be defined only once in the type namespace of this module

error[E0119]: conflicting implementations of trait `std::fmt::Debug` for type `models::gafete::CreateGafeteInput`
   --> src\models\gafete.rs:167:10
    |
 27 | #[derive(Debug, Deserialize)]
    |          ----- first implementation here
...
167 | #[derive(Debug, Deserialize)]
    |          ^^^^^ conflicting implementation for `models::gafete::CreateGafeteInput`

error[E0119]: conflicting implementations of trait `std::fmt::Debug` for type `models::gafete::CreateGafeteRangeInput`
   --> src\models\gafete.rs:174:10
    |
 34 | #[derive(Debug, Deserialize)]
    |          ----- first implementation here
...
174 | #[derive(Debug, Deserialize)]
    |          ^^^^^ conflicting implementation for `models::gafete::CreateGafeteRangeInput`

error[E0119]: conflicting implementations of trait `std::fmt::Debug` for type `models::gafete::GafeteCreateDTO`
   --> src\models\gafete.rs:198:10
    |
 44 | #[derive(Debug, Serialize)]
    |          ----- first implementation here
...
198 | #[derive(Debug, Serialize)]
    |          ^^^^^ conflicting implementation for `models::gafete::GafeteCreateDTO`

error[E0119]: conflicting implementations of trait `std::fmt::Debug` for type `models::gafete::GafeteResponse`
   --> src\models\gafete.rs:209:10
    |
 53 | #[derive(Debug, Serialize, Clone)]
    |          ----- first implementation here
...
209 | #[derive(Debug, Serialize, Clone)]
    |          ^^^^^ conflicting implementation for `models::gafete::GafeteResponse`

error[E0119]: conflicting implementations of trait `keyring_commands::_::_serde::Deserialize<'_>` for type `models::gafete::CreateGafeteInput`
   --> src\models\gafete.rs:167:17
    |
 27 | #[derive(Debug, Deserialize)]
    |                 ----------- first implementation here
...
167 | #[derive(Debug, Deserialize)]
    |                 ^^^^^^^^^^^ conflicting implementation for `models::gafete::CreateGafeteInput`
    |
    = note: this error originates in the derive macro `Deserialize` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0119]: conflicting implementations of trait `keyring_commands::_::_serde::Deserialize<'_>` for type `models::gafete::CreateGafeteRangeInput`
   --> src\models\gafete.rs:174:17
    |
 34 | #[derive(Debug, Deserialize)]
    |                 ----------- first implementation here
...
174 | #[derive(Debug, Deserialize)]
    |                 ^^^^^^^^^^^ conflicting implementation for `models::gafete::CreateGafeteRangeInput`
    |
    = note: this error originates in the derive macro `Deserialize` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0119]: conflicting implementations of trait `keyring_commands::_::_serde::Serialize` for type `models::gafete::GafeteCreateDTO`
   --> src\models\gafete.rs:198:17
    |
 44 | #[derive(Debug, Serialize)]
    |                 --------- first implementation here
...
198 | #[derive(Debug, Serialize)]
    |                 ^^^^^^^^^ conflicting implementation for `models::gafete::GafeteCreateDTO`
    |
    = note: this error originates in the derive macro `Serialize` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0119]: conflicting implementations of trait `keyring_commands::_::_serde::Serialize` for type `models::gafete::GafeteResponse`
   --> src\models\gafete.rs:209:17
    |
 53 | #[derive(Debug, Serialize, Clone)]
    |                 --------- first implementation here
...
209 | #[derive(Debug, Serialize, Clone)]
    |                 ^^^^^^^^^ conflicting implementation for `models::gafete::GafeteResponse`
    |
    = note: this error originates in the derive macro `Serialize` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0119]: conflicting implementations of trait `Clone` for type `models::gafete::GafeteResponse`
   --> src\models\gafete.rs:209:28
    |
 53 | #[derive(Debug, Serialize, Clone)]
    |                            ----- first implementation here
...
209 | #[derive(Debug, Serialize, Clone)]
    |                            ^^^^^ conflicting implementation for `models::gafete::GafeteResponse`

error[E0119]: conflicting implementations of trait `std::convert::From<Gafete>` for type `models::gafete::GafeteResponse`
   --> src\models\gafete.rs:222:1
    |
 66 | impl From<Gafete> for GafeteResponse {
    | ------------------------------------ first implementation here
...
222 | impl From<Gafete> for GafeteResponse {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `models::gafete::GafeteResponse`

error[E0308]: mismatched types
  --> src\commands\gafete_commands.rs:79:42
   |
79 |     gafete_service::is_gafete_disponible(&numero, &tipo)
   |     ------------------------------------ ^^^^^^^ expected `i32`, found `&String`
   |     |
   |     arguments to this function are incorrect
   |
note: function defined here
  --> src\services\gafete_service.rs:26:14
   |
26 | pub async fn is_gafete_disponible(numero: i32, tipo: &str) -> Result<bool, String> {
   |              ^^^^^^^^^^^^^^^^^^^^ -----------

error[E0308]: mismatched types
   --> src\services\cita_service.rs:161:9
    |
161 |         gafete_numero,
    |         ^^^^^^^^^^^^^ expected `Option<i32>`, found `Option<String>`
    |
    = note: expected enum `std::option::Option<i32>`
               found enum `std::option::Option<std::string::String>`

error[E0599]: no method named `is_empty` found for reference `&i32` in the current scope
   --> src\services\ingreso_contratista_service.rs:210:29
    |
210 |         if g != "S/G" && !g.is_empty() {
    |                             ^^^^^^^^ method not found in `&i32`

error[E0277]: can't compare `i32` with `str`
   --> src\services\ingreso_contratista_service.rs:210:14
    |
210 |         if g != "S/G" && !g.is_empty() {
    |              ^^ no implementation for `i32 == str`
    |
    = help: the trait `PartialEq<str>` is not implemented for `i32`
    = help: the following other types implement trait `PartialEq<Rhs>`:
              `i32` implements `PartialEq<JsonValue>`
              `i32` implements `PartialEq`
    = note: required for `&i32` to implement `PartialEq<&str>`

error[E0308]: mismatched types
   --> src\services\ingreso_contratista_service.rs:211:61
    |
211 |             let disp = gafete_service::is_gafete_disponible(g, "contratista")
    |                        ------------------------------------ ^ expected `i32`, found `&i32`
    |                        |
    |                        arguments to this function are incorrect
    |
note: function defined here
   --> src\services\gafete_service.rs:26:14
    |
 26 | pub async fn is_gafete_disponible(numero: i32, tipo: &str) -> Result<bool, String> {
    |              ^^^^^^^^^^^^^^^^^^^^ -----------
help: consider dereferencing the borrow
    |
211 |             let disp = gafete_service::is_gafete_disponible(*g, "contratista")
    |                                                             +

error[E0308]: mismatched types
   --> src\services\ingreso_contratista_service.rs:244:47
    |
244 |         let _ = gafete_service::marcar_en_uso(g, "contratista").await;
    |                 ----------------------------- ^ expected `i32`, found `&i32`
    |                 |
    |                 arguments to this function are incorrect
    |
note: function defined here
   --> src\services\gafete_service.rs:35:14
    |
 35 | pub async fn marcar_en_uso(numero: i32, tipo: &str) -> Result<(), String> {
    |              ^^^^^^^^^^^^^ -----------
help: consider dereferencing the borrow
    |
244 |         let _ = gafete_service::marcar_en_uso(*g, "contratista").await;
    |                                               +

error[E0308]: mismatched types
   --> src\services\ingreso_contratista_service.rs:280:52
    |
280 |             let _ = gafete_service::liberar_gafete(g, "contratista").await;
    |                     ------------------------------ ^ expected `i32`, found `&i32`
    |                     |
    |                     arguments to this function are incorrect
    |
note: function defined here
   --> src\services\gafete_service.rs:44:14
    |
 44 | pub async fn liberar_gafete(numero: i32, tipo: &str) -> Result<(), String> {
    |              ^^^^^^^^^^^^^^ -----------
help: consider dereferencing the borrow
    |
280 |             let _ = gafete_service::liberar_gafete(*g, "contratista").await;
    |                                                    +

error[E0599]: no method named `is_empty` found for reference `&i32` in the current scope
  --> src\services\ingreso_proveedor_service.rs:37:29
   |
37 |         if g != "S/G" && !g.is_empty() {
   |                             ^^^^^^^^ method not found in `&i32`

error[E0277]: can't compare `i32` with `str`
  --> src\services\ingreso_proveedor_service.rs:37:14
   |
37 |         if g != "S/G" && !g.is_empty() {
   |              ^^ no implementation for `i32 == str`
   |
   = help: the trait `PartialEq<str>` is not implemented for `i32`
   = help: the following other types implement trait `PartialEq<Rhs>`:
             `i32` implements `PartialEq<JsonValue>`
             `i32` implements `PartialEq`
   = note: required for `&i32` to implement `PartialEq<&str>`

error[E0308]: mismatched types
  --> src\services\ingreso_proveedor_service.rs:38:61
   |
38 |             let disp = gafete_service::is_gafete_disponible(g, "proveedor")
   |                        ------------------------------------ ^ expected `i32`, found `&i32`
   |                        |
   |                        arguments to this function are incorrect
   |
note: function defined here
  --> src\services\gafete_service.rs:26:14
   |
26 | pub async fn is_gafete_disponible(numero: i32, tipo: &str) -> Result<bool, String> {
   |              ^^^^^^^^^^^^^^^^^^^^ -----------
help: consider dereferencing the borrow
   |
38 |             let disp = gafete_service::is_gafete_disponible(*g, "proveedor")
   |                                                             +

error[E0599]: no method named `is_empty` found for reference `&i32` in the current scope
  --> src\services\ingreso_proveedor_service.rs:92:29
   |
92 |         if g != "S/G" && !g.is_empty() {
   |                             ^^^^^^^^ method not found in `&i32`

error[E0277]: can't compare `i32` with `str`
  --> src\services\ingreso_proveedor_service.rs:92:14
   |
92 |         if g != "S/G" && !g.is_empty() {
   |              ^^ no implementation for `i32 == str`
   |
   = help: the trait `PartialEq<str>` is not implemented for `i32`
   = help: the following other types implement trait `PartialEq<Rhs>`:
             `i32` implements `PartialEq<JsonValue>`
             `i32` implements `PartialEq`
   = note: required for `&i32` to implement `PartialEq<&str>`

error[E0308]: mismatched types
  --> src\services\ingreso_proveedor_service.rs:93:51
   |
93 |             let _ = gafete_service::marcar_en_uso(g, "proveedor").await;
   |                     ----------------------------- ^ expected `i32`, found `&i32`
   |                     |
   |                     arguments to this function are incorrect
   |
note: function defined here
  --> src\services\gafete_service.rs:35:14
   |
35 | pub async fn marcar_en_uso(numero: i32, tipo: &str) -> Result<(), String> {
   |              ^^^^^^^^^^^^^ -----------
help: consider dereferencing the borrow
   |
93 |             let _ = gafete_service::marcar_en_uso(*g, "proveedor").await;
   |                                                   +

error[E0599]: no method named `is_empty` found for reference `&i32` in the current scope
   --> src\services\ingreso_proveedor_service.rs:129:33
    |
129 |             if g != "S/G" && !g.is_empty() {
    |                                 ^^^^^^^^ method not found in `&i32`

error[E0277]: can't compare `i32` with `str`
   --> src\services\ingreso_proveedor_service.rs:129:18
    |
129 |             if g != "S/G" && !g.is_empty() {
    |                  ^^ no implementation for `i32 == str`
    |
    = help: the trait `PartialEq<str>` is not implemented for `i32`
    = help: the following other types implement trait `PartialEq<Rhs>`:
              `i32` implements `PartialEq<JsonValue>`
              `i32` implements `PartialEq`
    = note: required for `&i32` to implement `PartialEq<&str>`

error[E0308]: mismatched types
   --> src\services\ingreso_proveedor_service.rs:130:56
    |
130 |                 let _ = gafete_service::liberar_gafete(g, "proveedor").await;
    |                         ------------------------------ ^ expected `i32`, found `&i32`
    |                         |
    |                         arguments to this function are incorrect
    |
note: function defined here
   --> src\services\gafete_service.rs:44:14
    |
 44 | pub async fn liberar_gafete(numero: i32, tipo: &str) -> Result<(), String> {
    |              ^^^^^^^^^^^^^^ -----------
help: consider dereferencing the borrow
    |
130 |                 let _ = gafete_service::liberar_gafete(*g, "proveedor").await;
    |                                                        +

error[E0599]: no method named `is_empty` found for reference `&i32` in the current scope
  --> src\services\ingreso_visita_service.rs:31:29
   |
31 |         if g != "S/G" && !g.is_empty() {
   |                             ^^^^^^^^ method not found in `&i32`

error[E0277]: can't compare `i32` with `str`
  --> src\services\ingreso_visita_service.rs:31:14
   |
31 |         if g != "S/G" && !g.is_empty() {
   |              ^^ no implementation for `i32 == str`
   |
   = help: the trait `PartialEq<str>` is not implemented for `i32`
   = help: the following other types implement trait `PartialEq<Rhs>`:
             `i32` implements `PartialEq<JsonValue>`
             `i32` implements `PartialEq`
   = note: required for `&i32` to implement `PartialEq<&str>`

error[E0308]: mismatched types
  --> src\services\ingreso_visita_service.rs:32:61
   |
32 |             let disp = gafete_service::is_gafete_disponible(g, "visita")
   |                        ------------------------------------ ^ expected `i32`, found `&i32`
   |                        |
   |                        arguments to this function are incorrect
   |
note: function defined here
  --> src\services\gafete_service.rs:26:14
   |
26 | pub async fn is_gafete_disponible(numero: i32, tipo: &str) -> Result<bool, String> {
   |              ^^^^^^^^^^^^^^^^^^^^ -----------
help: consider dereferencing the borrow
   |
32 |             let disp = gafete_service::is_gafete_disponible(*g, "visita")
   |                                                             +

error[E0599]: no method named `is_empty` found for reference `&i32` in the current scope
  --> src\services\ingreso_visita_service.rs:79:29
   |
79 |         if g != "S/G" && !g.is_empty() {
   |                             ^^^^^^^^ method not found in `&i32`

error[E0277]: can't compare `i32` with `str`
  --> src\services\ingreso_visita_service.rs:79:14
   |
79 |         if g != "S/G" && !g.is_empty() {
   |              ^^ no implementation for `i32 == str`
   |
   = help: the trait `PartialEq<str>` is not implemented for `i32`
   = help: the following other types implement trait `PartialEq<Rhs>`:
             `i32` implements `PartialEq<JsonValue>`
             `i32` implements `PartialEq`
   = note: required for `&i32` to implement `PartialEq<&str>`

error[E0308]: mismatched types
  --> src\services\ingreso_visita_service.rs:80:51
   |
80 |             let _ = gafete_service::marcar_en_uso(g, "visita").await;
   |                     ----------------------------- ^ expected `i32`, found `&i32`
   |                     |
   |                     arguments to this function are incorrect
   |
note: function defined here
  --> src\services\gafete_service.rs:35:14
   |
35 | pub async fn marcar_en_uso(numero: i32, tipo: &str) -> Result<(), String> {
   |              ^^^^^^^^^^^^^ -----------
help: consider dereferencing the borrow
   |
80 |             let _ = gafete_service::marcar_en_uso(*g, "visita").await;
   |                                                   +

error[E0277]: can't compare `i32` with `str`
   --> src\services\ingreso_visita_service.rs:116:18
    |
116 |             if g != "S/G" {
    |                  ^^ no implementation for `i32 == str`
    |
    = help: the trait `PartialEq<str>` is not implemented for `i32`
    = help: the following other types implement trait `PartialEq<Rhs>`:
              `i32` implements `PartialEq<JsonValue>`
              `i32` implements `PartialEq`
    = note: required for `&i32` to implement `PartialEq<&str>`

error[E0308]: mismatched types
   --> src\services\ingreso_visita_service.rs:117:56
    |
117 |                 let _ = gafete_service::liberar_gafete(g, "visita").await;
    |                         ------------------------------ ^ expected `i32`, found `&i32`
    |                         |
    |                         arguments to this function are incorrect
    |
note: function defined here
   --> src\services\gafete_service.rs:44:14
    |
 44 | pub async fn liberar_gafete(numero: i32, tipo: &str) -> Result<(), String> {
    |              ^^^^^^^^^^^^^^ -----------
help: consider dereferencing the borrow
    |
117 |                 let _ = gafete_service::liberar_gafete(*g, "visita").await;
    |                                                        +

error[E0308]: mismatched types
   --> src\domain\motor_validacion.rs:119:28
    |
119 |             gafete_numero: common.gafete_activo_numero.clone().unwrap_or_default(),
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `i32`
    |
help: try using a conversion method
    |
119 |             gafete_numero: common.gafete_activo_numero.clone().unwrap_or_default().to_string(),
    |                                                                                   ++++++++++++

Some errors have detailed explanations: E0119, E0277, E0308, E0428, E0599.
For more information about an error, try `rustc --explain E0119`.
error: could not compile `mega-brisas` (lib) due to 39 previous errors
